// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: RacketsForSale.sql

package db

import (
	"context"
)

const createRacketsForSale = `-- name: CreateRacketsForSale :one
INSERT INTO "RacketsForSale" (
  carbon_type, 
  grip_type, 
  price,
  seller_id,
  status
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING id, carbon_type, grip_type, price, seller_id, posted_time, status, buyer_id
`

type CreateRacketsForSaleParams struct {
	CarbonType CarbonType `json:"carbon_type"`
	GripType   GripType   `json:"grip_type"`
	Price      int64      `json:"price"`
	SellerID   int64      `json:"seller_id"`
	Status     Status     `json:"status"`
}

func (q *Queries) CreateRacketsForSale(ctx context.Context, arg CreateRacketsForSaleParams) (RacketsForSale, error) {
	row := q.db.QueryRowContext(ctx, createRacketsForSale,
		arg.CarbonType,
		arg.GripType,
		arg.Price,
		arg.SellerID,
		arg.Status,
	)
	var i RacketsForSale
	err := row.Scan(
		&i.ID,
		&i.CarbonType,
		&i.GripType,
		&i.Price,
		&i.SellerID,
		&i.PostedTime,
		&i.Status,
		&i.BuyerID,
	)
	return i, err
}

const deleteSellingRacket = `-- name: DeleteSellingRacket :exec
DELETE FROM accounts 
WHERE id = $1 and "status" = 'Selling'
`

func (q *Queries) DeleteSellingRacket(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteSellingRacket, id)
	return err
}

const listAllRackets = `-- name: ListAllRackets :many
SELECT id, carbon_type, grip_type, price, seller_id, posted_time, status, buyer_id FROM "RacketsForSale"
WHERE "status" = 'Selling'
LIMIT $1
`

func (q *Queries) ListAllRackets(ctx context.Context, limit int32) ([]RacketsForSale, error) {
	rows, err := q.db.QueryContext(ctx, listAllRackets, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RacketsForSale
	for rows.Next() {
		var i RacketsForSale
		if err := rows.Scan(
			&i.ID,
			&i.CarbonType,
			&i.GripType,
			&i.Price,
			&i.SellerID,
			&i.PostedTime,
			&i.Status,
			&i.BuyerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRaquets = `-- name: ListRaquets :many
SELECT id, carbon_type, grip_type, price, seller_id, posted_time, status, buyer_id FROM "RacketsForSale"
WHERE "price" BETWEEN $2 AND $3
  AND "grip_type" = $4
  AND "carbon_type" = $5
  AND "status" = 'Selling'
LIMIT $1
`

type ListRaquetsParams struct {
	Limit      int32      `json:"limit"`
	Price      int64      `json:"price"`
	Price_2    int64      `json:"price_2"`
	GripType   GripType   `json:"grip_type"`
	CarbonType CarbonType `json:"carbon_type"`
}

func (q *Queries) ListRaquets(ctx context.Context, arg ListRaquetsParams) ([]RacketsForSale, error) {
	rows, err := q.db.QueryContext(ctx, listRaquets,
		arg.Limit,
		arg.Price,
		arg.Price_2,
		arg.GripType,
		arg.CarbonType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RacketsForSale
	for rows.Next() {
		var i RacketsForSale
		if err := rows.Scan(
			&i.ID,
			&i.CarbonType,
			&i.GripType,
			&i.Price,
			&i.SellerID,
			&i.PostedTime,
			&i.Status,
			&i.BuyerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccountFeatures = `-- name: UpdateAccountFeatures :one
UPDATE "RacketsForSale"
SET "price" = $1, "grip_type" = $2, "carbon_type" = $3
WHERE "id" = $4 AND "status" = 'Selling'
RETURNING id, carbon_type, grip_type, price, seller_id, posted_time, status, buyer_id
`

type UpdateAccountFeaturesParams struct {
	Price      int64      `json:"price"`
	GripType   GripType   `json:"grip_type"`
	CarbonType CarbonType `json:"carbon_type"`
	ID         int64      `json:"id"`
}

func (q *Queries) UpdateAccountFeatures(ctx context.Context, arg UpdateAccountFeaturesParams) (RacketsForSale, error) {
	row := q.db.QueryRowContext(ctx, updateAccountFeatures,
		arg.Price,
		arg.GripType,
		arg.CarbonType,
		arg.ID,
	)
	var i RacketsForSale
	err := row.Scan(
		&i.ID,
		&i.CarbonType,
		&i.GripType,
		&i.Price,
		&i.SellerID,
		&i.PostedTime,
		&i.Status,
		&i.BuyerID,
	)
	return i, err
}

const updateAccountStatus = `-- name: UpdateAccountStatus :one
UPDATE "RacketsForSale"
SET "status" = 'Sold'
WHERE "id" = $1
RETURNING id, carbon_type, grip_type, price, seller_id, posted_time, status, buyer_id
`

func (q *Queries) UpdateAccountStatus(ctx context.Context, id int64) (RacketsForSale, error) {
	row := q.db.QueryRowContext(ctx, updateAccountStatus, id)
	var i RacketsForSale
	err := row.Scan(
		&i.ID,
		&i.CarbonType,
		&i.GripType,
		&i.Price,
		&i.SellerID,
		&i.PostedTime,
		&i.Status,
		&i.BuyerID,
	)
	return i, err
}
